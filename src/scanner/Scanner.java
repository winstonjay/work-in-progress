/*
Scanner :
implements methods and stores state needed to perform lexical scanning on a
input. Its main method `nextToken` progresses scanners position and returns
the either the next valid token, a UNEXPECTED token or if it has reached the
end of the input a EOF token. It is designed to be called by a parser until
a EOF token is reached. Scanner leaves all error handling to a future parser.

E.g. usage:

    Scanner scanner = new Scanner(inputString);
    Token t = scanner.nextToken();
    while (t.type != scanner.EOF_TYPE) {
        System.out.println(t);
        t = scanner.nextToken();
    }
    System.out.println(t);

This will all print tokens generated by the scanner finishing with a EOF.

refs:
https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
https://pragprog.com/book/tpdsl/language-implementation-patterns
*/
import java.lang.StringBuilder;

public class Scanner extends ScannerAbstract {

    public static int NUMBER = 2;   // number types
    public static int NAME   = 3;   // varible names
    public static int ADD    = 4;   // +
    public static int SUB    = 5;   // -
    public static int MUL    = 6;   // *
    public static int DIV    = 7;   // /
    public static int LPAREN = 8;   // (
    public static int RPAREN = 9;   // )
    public static int COMMA  = 10;  // ,
    public static int DOT    = 11;  // .
    public static int EQUALS = 12;  // =

    public static String[] tokenNames = {
        "EOF",
        "UNEXPECTED",
        "NUMBER",
        "NAME",
        "ADD",
        "SUB",
        "MUL",
        "DIV",
        "LPAREN",
        "RPAREN",
        "COMMA",
        "DOT",
        "EQUALS"
    };

    public Scanner(String input) {
        super(input);
    }

    // nextToken : returns the next encountered token.
    public Token nextToken() {
        Token tok;
        while (curr != EOF) {
            switch (curr) {
                case ' ': case '\t': case '\n': case '\r':
                    skipWhitespace();
                    continue;
                case '+':
                    tok = new Token(ADD, "+");
                    break;
                case '-':
                    tok = new Token(SUB, "-");
                    break;
                case '/':
                    tok = new Token(DIV, "/");
                    break;
                case '*':
                    tok = new Token(MUL, "*");
                    break;
                case '(':
                    tok = new Token(LPAREN, "(");
                    break;
                case ')':
                    tok = new Token(RPAREN, ")");
                    break;
                case ',':
                    tok = new Token(COMMA, ",");
                    break;
                case '=':
                    tok = new Token(EQUALS, "=");
                    break;
                default:
                    if (isDigit()) {
                        return scanNumber();
                    }
                    if (isLetter()) {
                        return scanName();
                    }
                    tok = new Token(UNEXPECTED_TYPE, "n/a");
            }
            advance(); // always advance the current position.
            return tok;
        }
        return new Token(EOF_TYPE, "EOF");
    }

    // scanName : return group of alphnumeric chars.
    Token scanName() {
        StringBuilder buf = new StringBuilder();
        do {
            buf.append(curr);
            advance();
        } while (isLetter());
        return new Token(NAME, buf.toString());
    }

    // scanNumber : return a valid number. A number can be a repsented in base 10,
    // hex, binary and floating point form.
    Token scanNumber() {
        StringBuilder buf = new StringBuilder();
        boolean zeros = true;
        do {
            if (zeros && (curr != '0' || buf.length() >= 1)) {
                zeros = false;
            }
            buf.append(curr);
            advance();
        } while (isDigit());

        // hex is preceded by '0x', binary by '0b', if the scanner tries to parse a hex
        // or binary number and it is malformed (contains more than just one zero before
        // the aphanumeric indicator) the function will return a UNEXPECTED token type with
        // the collected string.
        switch (curr) {
            case '.':
                do {
                    buf.append(curr);
                    advance();
                } while (isDigit());
                break;
            case 'x': case 'X':
                do {
                    buf.append(curr);
                    advance();
                } while (isHex());
                if (!zeros) {
                    return new Token(UNEXPECTED_TYPE, buf.toString());
                }
                break;
            case 'b': case 'B':
                do {
                    buf.append(curr);
                    advance();
                } while (isBinary());
                if (!zeros) {
                    return new Token(UNEXPECTED_TYPE, buf.toString());
                }
                break;
            default:
        }
        return new Token(NUMBER, buf.toString());
    }

    // skipWhitespace : advance the reader through whitespace keeping track of
    // newline tokens.
    void skipWhitespace() {
        while (curr == ' ' || curr == '\t' || curr == '\n' || curr == '\r') {
            if (curr == '\n' || curr == '\r') {
                linenum++;
            }
            advance();
        }
    }

    boolean isLetter() {
        return ((curr >= 'a' && curr <= 'z') ||
                (curr >= 'A' && curr <= 'Z') || curr == '_');
    }

    boolean isDigit() {
        return (curr >= '0' && curr <= '9');
    }

    boolean isHex() {
        return ((curr >= 'a' && curr <= 'f') ||
                (curr >= 'A' && curr <= 'F') || isDigit());
    }

    boolean isBinary() {
        return (curr == '0' || curr == '1');
    }
}